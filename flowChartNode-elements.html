<link rel="import" href="bower_components/iron-input/iron-input.html">
<link rel="import" href="flowChartNode-behavior.html">
<link rel="import" href="comment-element.html">
<link rel="import" href="condition-element.html">

<!-- Contains the different kind of FlowChartNodes -->
<!-- The common base and drag and drop is in flowChartNode-behavior defined -->

<dom-module id="ObjectiveNode-element">
<style>
	:host {
		background-color: #96C5F7;
		width: 260px;
		display: flex;
		margin: 10px;
	}

	.direction {
		float: right;
	}

	.left, .right, .leftmiddle {
		width: 40px;
		padding: 10px 5px;
		background-color: #A9D3FF;
		position: relative;
	}

	.left {
		border-top-right-radius: 20px;
		border-bottom-right-radius: 20px;
		padding-right: 18px;
	}

	.right {
		border-top-left-radius: 20px;
		border-bottom-left-radius: 20px;
		padding-right: 18px;
	}

	.leftmiddle {
		border-radius: 20px;
		padding: 12px;
		margin-left: 3px;
	}
	.center {
		margin: 10px;
	}

	.left > span, .leftmiddle > span {
	    position: absolute;
		transform: translate(0px, -12px) rotate(90deg);
	    transform-origin: left bottom 0;
	}

	.leftmiddle > span {
		transform: translate(-4px, -26px) rotate(90deg);
	}
	
	.left > conditions, .leftmiddle > enterScripts, .right > exitScripts {
		display: none;
		position: absolute;
		width: 500px;
		background-color: #75A6C6;
		z-index: 10;
		left: 25px;
		top: 30px;
		padding: 10px;
	}

	.left:hover > conditions, .leftmiddle:hover > enterScripts, .right:hover > exitScripts {
		display: block;
	}

	conditions:hover, enterScripts:hover, exitScripts:hover {
		display: block;
	}
	
	.right > span {
		position: absolute;
	    transform: translate(0px, 86px) rotate(270deg);
	    transform-origin: left top 0;
	}

	comments {
	}
</style>
<template>
		<div class="left">
			<span>Conditions</span>
			<conditions></conditions>
		</div>
		<div class="leftmiddle">
			<span>Enter&nbsp;Scripts</span>
			<enterScripts></enterScripts>
		</div>
		<div class="center">
		<div>Type: <span>{{type}}</span><span class="direction">{{direction}}</span></div>
		<div>ID: <input is="iron-input" bind-value={{nodeId}}></input></div>
		<div>Comments: <button on-click="addComment">Add</button></div>
		<comments></comments>
		</div>
		<div class="right" on-click="showEffects">
			<span>Exit&nbsp;Scripts</span>
			<exitScripts></exitScripts>
		</div>
</template>
</dom-module>

<dom-module id="TalkNode-element">
<style>
	:host {
		background-color: #8FC0A9;
		width: 260px;
		display: flex;
		margin: 10px;
	}
	
	:host.selected {
		background-color: #E2EB98;
	}

	.direction {
		float: right;
	}

	.left, .right, .leftmiddle {
		width: 40px;
		padding: 10px 5px;
		background-color: #9FD8CB;
		position: relative;
	}

	.left {
		border-top-right-radius: 20px;
		border-bottom-right-radius: 20px;
		padding-right: 18px;
	}

	.right {
		border-top-left-radius: 20px;
		border-bottom-left-radius: 20px;
		padding-right: 18px;
	}

	.leftmiddle {
		border-radius: 20px;
		padding: 12px;
		margin-left: 3px;
	}
	.center {
		margin: 10px;
	}

	.left > span, .leftmiddle > span {
	    position: absolute;
		transform: translate(0px, -12px) rotate(90deg);
	    transform-origin: left bottom 0;
	}

	.leftmiddle > span {
		transform: translate(-4px, -26px) rotate(90deg);
	}
	
	.left > conditions, .leftmiddle > enterScripts, .right > exitScripts {
		display: none;
		position: absolute;
		width: 500px;
		background-color: #ADBF97;
		z-index: 10;
		left: 25px;
		top: 30px;
		padding: 10px;
	}

	.left:hover > conditions, .leftmiddle:hover > enterScripts, .right:hover > exitScripts {
		display: block;
	}

	conditions:hover, enterScripts:hover, exitScripts:hover {
		display: block;
	}
	
	.right > span {
		position: absolute;
	    transform: translate(0px, 86px) rotate(270deg);
	    transform-origin: left top 0;
	}

	comments {
	}
</style>
<template>
		<div class="left">
			<span>Conditions</span>
			<conditions></conditions>
		</div>
		<div class="leftmiddle">
			<span>Enter&nbsp;Scripts</span>
			<enterScripts></enterScripts>
		</div>
		<div class="center">
			<div>Type: <span>{{type}}</span><span class="direction">{{direction}}</span></div>
			<div>ID: <input is="iron-input" bind-value={{nodeId}}></input></div>
			<div>Comments: <button on-click="addComment">Add</button></div>
			<comments></comments>
		</div>
		<div class="right" on-click="showEffects">
			<span>Exit&nbsp;Scripts</span>
			<exitScripts></exitScripts>
		</div>
</template>
</dom-module>


<script>
"use strict";
	var ObjectiveNode = Polymer({
		is: "ObjectiveNode-element",
		behaviors: [FlowChartNodeBehavior],

		created: function() {
			this.comments = [];
			this.links = {};
			this.conditions = [];
			this.enterScripts = [];
			this.exitScripts = [];
		},

		createLink: function(to) {
			if (!(to.id in this.links)) {
				this.links[to.id] = new QuestLink(this, to);
				document.getElementsByTagName("body")[0].appendChild(this.links[to.id]);
			}
		},

		activateLinks: function(nodesMap) { // linkXML in echte links überführen
			if (this.linkXML.hasChildNodes()) {
				var node;
				for (var x = 0; x < this.linkXML.childNodes.length; x++) {
					node = this.linkXML.childNodes[x];
					if (node.nodeName == "FlowChartLink") {
						var questLink = new QuestLink(); // parameter zum Glück nicht lebenswichtig
						questLink.fromXML(node, nodesMap);
						this.links[questLink.endElement.id] = questLink;
					}
				}
			}
		},

		fromXML: function(xml) {
			this._fromXML(xml);
			if (xml.hasChildNodes()) { // TODO rest
				var node;
				for (var x = 0; x < xml.childNodes.length; x++) {
					node = xml.childNodes[x];
					if (node.nodeName == "EndState") {
					}
					if (node.nodeName == "ExperienceType") {
					}
					if (node.nodeName == "ExperienceLevel") {
					}
				}
			}
		},

		toXML: function() {
			var xml = '<FlowChartNode xsi:type="' + this.type + '">' + this._toXML();
			// TODO
			return xml + '</FlowChartNode>';
		}
	});

	var TalkNode = Polymer({
		is: "TalkNode-element",
		behaviors: [FlowChartNodeBehavior],

		properties: {
			conditions: Array
		},

		created: function() {
			this.comments = [];
			this.links = {};
			this.conditions = [];
			this.enterScripts = [];
			this.exitScripts = [];
		},

		attached: function() {
		},

		/** Create Links via Drag and Drop */
		createLink: function(to) {
			if (!(to.id in this.links)) {
				this.links[to.id] = new DialogueLink(this, to);
				document.getElementsByTagName("body")[0].appendChild(this.links[to.id]);
			}
		},

		activateLinks: function(nodesMap) { // linkXML in echte links überführen
			if (this.linkXML.hasChildNodes()) {
				var node;
				for (var x = 0; x < this.linkXML.childNodes.length; x++) {
					node = this.linkXML.childNodes[x];
					if (node.nodeName == "FlowChartLink") {
						var dialogueLink = new DialogueLink(); // parameter zum Glück nicht lebenswichtig
						dialogueLink.fromXML(node, nodesMap);
						this.links[dialogueLink.endElement.id] = dialogueLink;
					}
				}
			}
		},

		fromXML: function(xml) {
			this._fromXML(xml);
			if(xml.hasChildNodes) {
				var node;
				for (var x = 0; x < xml.childNodes.length; x++) { // TODO 
					node = xml.childNodes[x];
					if (node.nodeName == "NotSkippable") {
					}
					if (node.nodeName == "IsQuestionNode") {
					}
					if (node.nodeName == "IsTempText") {
					}
					if (node.nodeName == "PlayVOAs3DSound") {
					}
					if (node.nodeName == "PlayType") {
					}
					if (node.nodeName == "Persistence") {
					}
					if (node.nodeName == "NoPlayRandomWeight") {
					}
					if (node.nodeName == "DisplayType") {
					}
				}
			}
		},

		toXML: function() {
			var xml = '<FlowChartNode xsi:type="' + this.type + '">' + this._toXML();
			// TODO
			return xml + '</FlowChartNode>';
		}
	});
</script>
