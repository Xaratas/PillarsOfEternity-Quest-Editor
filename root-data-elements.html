<link rel="import" href="bower_components/polymer/polymer.html">
<link rel="import" href="parser-behavior.html">
<link rel="import" href="flowChartNode-elements.html">

<!-- Quest Farbpalette
	Hell: #EDEFFF
	hell blau: #A9D3FF
	mittel blau: #96C5F7
	dunkel blau: #75A6C6
	highlight gr端n: #6782A7
-->	

<dom-module id="QuestData-element">
	<style>
		:host {
			display: flex;
		}

		:host > ::content > div {
			display:flex;
			flex-direction: column;
			margin-left: 30px;
			margin-right: 30px;
		}

		:host > ::content > div:first-child {
			margin-left: 0;	
		}

		:host > ::content > div:last-child {
			margin-right: 0;
		}
	</style>
	<template>
		<content></content>
	</template>
</dom-module>

<!-- Farbpalette:
	Hell: #D1FCF0
	helles cyan: #9FD8CB
	muted gr端n: #8FC0A9
	ocker: #ADBF97
	highlight muted gelb: #E2EB98
-->

<dom-module id="ConversationData-element">
	<style>
		:host {
			display: flex;
		}

		:host > ::content > div {
			display:flex;
			flex-direction: column;
			margin-left: 30px;
			margin-right: 30px;
		}

		:host > ::content > div:first-child {
			margin-left: 0;	
		}
	   
		:host > ::content > div:last-child {
			margin-right: 0;
		}
	</style>

	<template>
		<content></content>
	</template>
</dom-module>

<script>
"use strict";
	var QuestData = Polymer({
		is: "QuestData-element",
		behaviors: [ParserBehavior],

		created: function() {
			this.type = "QuestData";
		},

		// geht erstmal von text aus, hab noch kein file handling
		fromXML: function(xml) {
			if(typeof(xml) == "string") { // schon geparstes ist object
				xml = this.parser.parseFromString(xml, 'text/xml');
				this.cleanFormatting(xml);
			}
			if(xml.hasChildNodes()) {
				var item;
				for(var x = 0; x < xml.childNodes.length; x++) {
					item = xml.childNodes[x];
					if(item.nodeName == this.type) {
						this.fromXML(item); // remove outer layer
					}
					if(item.nodeName == "NextNodeID") {
						this.nextNodeId = item.childNodes[0].nodeValue;
					}
					if(item.nodeName == "Nodes") {
						// 端ber alle
						var node, element;
						for(var n = 0; n < item.childNodes.length; n++) {
							node = item.childNodes[n];
							if(node.nodeName == "FlowChartNode") {
								// type rausfiddeln
								switch(node.attributes[0].value) {
									case "QuestNode": element = new QuestNode(this);
													  break;
									case "ObjectiveNode": element = new ObjectiveNode(this);
														  break;
								}
								element.fromXML(node);
							}
							// bookmarks, classextender, usw.
							this.push("nodes", element);
							this.nodesMap[element.id] = element;
						}
						// links aus dem Temp Status umformen
						this.nodes.forEach(function(node) {
							node.$.flowchartnode.activateLinks(this.nodesMap);
						}, this);
						// nodes anhand der links sortieren
						var i = 0;
						this.nodes.forEach(function(node) {
							if(node.placed === false) {
								if(this.buckets[i] === undefined) this.buckets[i] = [];
								this.buckets[i].push(node); // id 0 als anker
								node.placed = true;
								i++;
								this.place(node.$.flowchartnode.links, i);
							}
						}, this);
						// dom anpassen, quasi eigenes template
						this.buckets.forEach(function(bucket) {
							var bucketWrapper = document.createElement('div');
							Polymer.dom(this).appendChild(bucketWrapper);
							bucket.forEach(function(node_) {
								Polymer.dom(bucketWrapper).appendChild(node_);
							});
						}, this);
					}
					if(item.nodeName == "Bookmarks") {} // ignore
					if(item.nodeName == "ClassExtender") {} // ignore
					if(item.nodeName == "NextEventID") {
						this.nextEventID = item.textContent;
					}
					if(item.nodeName == "NextEndStateID") {
						this.nextEndStateID = item.textContent;
					}
					if(item.nodeName == "NextAddendumID") {
						this.nextAddendumID = item.textContent;
					}
					if(item.nodeName == "Events") {
						// TODO
					}
					if(item.nodeName == "QuestType") {
						this.questType = PoeQuestEditor.QuestType[parseInt(item.textContent)];
					}
				}
			}
		},

		toXML: function() {
			var result = this.basetypecontent_toXML();
			result += '<NextEventID>' + this.nextEventID + '</NextEventID>';
			result += '<NextEndStateID>' + this.nextEventID + '</NextEndStateID>';
			result += '<NextAddendumID>' + this.nextAddendumID + '</NextAddendumID>';
			result += '<Events>';
				// TODO
			result += '</Events>';
			result += '<QuestType>'; // Ist als int im xml, Obsidian hat ihren Code selbst verhunzt -.-
		    if(this.questType == PoeQuestEditor.QuestType[0]) { 
				result += '0';
			}
			if(this.questType == PoeQuestEditor.QuestType[1]) {
				result += '1';
			}
			if(this.questType == PoeQuestEditor.QuestType[2]) {
				result += '2';
			}
			result += '</QuestType>';
			return result += '</' + this.type + '>';
		},


		stringsFromXMLNode: function(node) {
			var types = ["QuestNode", "ObjectiveNode"];
			if(node.nodeName == "Entries") {
				var entry;
				for(var n = 0; n < node.childNodes.length; n++) {
					entry = node.childNodes[n];
					types.forEach(function(type) {
						var id = entry.childNodes[0].textContent;
						var textType = "title";
						var flowChartNode;
						if(id >= 10000 && id < 20000) {
							id -= 10000;
							textType = "description";
						}
						if(id >= 20000 && id < 30000) {
							id -= 20000;
							textType = "addendum";
						}
						if(id >= 30000) {
							id -= 30000;
							textType = "endState";
							flowChartNode = this.nodesMap["QuestNode" + 0];
							flowChartNode.setText(entry.childNodes[1].textContent, entry.childNodes[2].textContent, textType, id);
						}
						if(textType == "addendum") {
							for(var i = 0; i < this.nodes.length; i++) {
								if(this.nodes[i].type == "ObjectiveNode" && 
										this.nodes[i].addendumIds.some(
											function(val, index) { 
												if(val.id == id) return true;
											}
										)) {
									flowChartNode = this.nodes[i];
									flowChartNode.setText(entry.childNodes[1].textContent, entry.childNodes[2].textContent, textType, id);
									break;
								}
							}
						}
						if(textType == "description" || textType == "title") {
							flowChartNode = this.nodesMap[type + id];
							if(flowChartNode !== undefined) {
								flowChartNode.setText(entry.childNodes[1].textContent, entry.childNodes[2].textContent, textType);
							}
						}
					}, this);
				}
			}
		}
	});

	var ConversationData = Polymer({
		is: "ConversationData-element",
		behaviors: [ParserBehavior],

		properties: {
			/** Valid Values: Conversation or Chatter */
			conversationType: String,
			characterMappings: {
				type: Array, // array of objects with Guid and InstanceTag
				value: function() { return []; }
			}
		},

		created: function() {
			this.type = "ConversationData";
		},

		fromXML: function(xml) {
			if(typeof(xml) == "string") { // schon geparstes ist object
				xml = this.parser.parseFromString(xml, 'text/xml');
				this.cleanFormatting(xml);
			}
			if(xml.hasChildNodes()) {
				var item;
				for(var x = 0; x < xml.childNodes.length; x++) {
					item = xml.childNodes[x];
					if(item.nodeName == this.type) {
						this.fromXML(item); // remove outer layer
					}
					if(item.nodeName == "NextNodeID") {
						this.nextNodeId = item.childNodes[0].nodeValue;
					}
					if(item.nodeName == "Nodes") {
						// 端ber alle
						var node, element;
						for(var n = 0; n < item.childNodes.length; n++) {
							node = item.childNodes[n];
							if(node.nodeName == "FlowChartNode") {
								// type rausfiddeln
								switch(node.attributes[0].value) {
									case "TalkNode":
										element = new TalkNode(this);
										break;
									case "PlayerResponseNode":
										element = new PlayerResponseNode(this);
										break;
									case "TriggerConversationNode":
										element = new TriggerConversationNode(this);
										break;
									case "BankNode":
										element = new BankNode(this);
										break;
									case "ScriptNode":
										element = new ScriptNode(this);
										break;
								}
								element.fromXML(node);
							}
							// bookmarks, classextender, usw.
							this.push("nodes", element);
							this.nodesMap[element.id] = element;
						}
						// links aus dem Temp Status umformen
						this.nodes.forEach(function(node) {
							if(node.$.dialoguenode !== undefined) {
								node.$.dialoguenode.$.flowchartnode.activateLinks(this.nodesMap);
							} else {
								node.$.flowchartnode.activateLinks(this.nodesMap);
							}
						}, this);
						// nodes anhand der links sortieren
						var i = 0;
						this.nodes.forEach(function(node) {
							if(node.placed === false) {
								if(this.buckets[i] === undefined) this.buckets[i] = [];
								this.buckets[i].push(node); // id 0 als anker
								node.placed = true;
								i++;
								if(node.$.dialoguenode !== undefined) {
									this.place(node.$.dialoguenode.$.flowchartnode.links, i);
								} else {
									this.place(node.$.flowchartnode.links, i);
								}
							}
						}, this);
						// dom anpassen, quasi eigenes template
						this.buckets.forEach(function(bucket) {
							var bucketWrapper = document.createElement('div');
							Polymer.dom(this).appendChild(bucketWrapper);
							bucket.forEach(function(node_) {
								Polymer.dom(bucketWrapper).appendChild(node_);
							});
						}, this);
					}
					if(item.nodeName == "Bookmarks") {} // ignore
					if(item.nodeName == "ClassExtender") {} // ignore
					if(item.nodeName == "ConversationType") {
						this.conversationType = item.textContent;
					}
					if(item.nodeName == "Description") {} // ignore
					if(item.nodeName == "SceneLocation") {} // ignore
					if(item.nodeName == "SceneTime") {} // ignore
					if(item.nodeName == "CharacterMappings") {
						if(item.hasChildNodes()) {
							var node;
							for(var i = 0; i < item.childNodes.length; i++) {
								node = item.childNodes[i];
								if(node.hasChildNodes()) {
									var guid = node.childNodes[0].textContent;
									var instanceTag = node.childNodes[1].textContent;
									this.characterMappings[i] = {'guid' : guid, 'instanceTag': instanceTag};
								}
							}
						}
					}
				}
			}
		},
		
		toXML: function() {
			var result = this.basetypecontent_toXML();
			// todo nicht gleiches
			result += '<ConversationType>' + this.conversationType + '</ConversationType>';
			// Nicht weiter wichtig, solange die Community nicht einen Weg findet die Texte zu vertonen
			result += '<Description>Scene description.</Description>';
			result += '<SceneLocation>SCENE LOCATION</SceneLocation>';
			result += '<SceneTime>SCENE TIME</SceneTime>';
			result += '<CharacterMappings>';
			for(var i = 0; i < this.characterMappings.length; i++) {
				result += '<CharacterMapping>';
				result += '<Guid>' + this.characterMappings[i].guid + '</Guid>';
				result += '<InstanceTag>' + this.characterMappings[i].instanceTag + '</InstanceTag>';
				result += '</CharacterMapping>';
			}
			result += '</CharacterMappings>';
			return result + '</' + this.type + '>';
		},

		stringsFromXMLNode: function(node) {	
			var types = ["TalkNode", "PlayerResponseNode", "TriggerConversationNode", "BankNode", "ScriptNode"];
			if(node.nodeName == "Entries") {
				var entry;
				for(var n = 0; n < node.childNodes.length; n++) {
					entry = node.childNodes[n];
					types.forEach(function(type) {
						var talkNode = this.nodesMap[type + entry.childNodes[0].textContent];
						if(talkNode !== undefined) {
							talkNode.setText(entry.childNodes[1].textContent, entry.childNodes[2].textContent);
						}
					}, this);
				}
			}
		}
	});
</script>
