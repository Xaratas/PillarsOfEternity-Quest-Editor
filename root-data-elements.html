<link rel="import" href="bower_components/polymer/polymer.html">
<link rel="import" href="parser-behavior.html">
<link rel="import" href="flowChartNode-elements.html">

<!-- Quest Farbpalette
	Hell: #EDEFFF
	hell blau: #A9D3FF
	mittel blau: #96C5F7
	dunkel blau: #75A6C6
	highlight gr端n: #6782A7
-->	

<dom-module id="QuestData-element">
	<style>
		:host {
			display: flex;
		}

		:host > ::content > div {
			display:flex;
			flex-direction: column;
			margin-left: 30px;
		    margin-right: 30px;
		}

		:host > ::content > div:first-child {
			margin-left: 0;	
		}
	   
		:host > ::content > div:last-child {
			margin-right: 0;
		}
	</style>
	<template>
		<content></content>
	</template>
</dom-module>

<!-- Farbpalette:
	Hell: #D1FCF0
	helles cyan: #9FD8CB
	muted gr端n: #8FC0A9
	ocker: #ADBF97
	highlight muted gelb: #E2EB98
-->

<dom-module id="ConversationData-element">
	<style>
		:host {
			display: flex;
		}

		:host > ::content > div {
			display:flex;
			flex-direction: column;
			margin-left: 30px;
		    margin-right: 30px;
		}

		:host > ::content > div:first-child {
			margin-left: 0;	
		}
	   
		:host > ::content > div:last-child {
			margin-right: 0;
		}
	</style>

	<template>
		<content></content>
	</template>
</dom-module>

<script>
"use strict";

	var QuestData = Polymer({
		is: "QuestData-element",
        behaviors: [ParserBehavior],

		created: function() {
            this.type = "QuestData";
			this.nodes = [];
			this.nodesMap = {};
			this.buckets = [];
        },

		// geht erstmal von text aus, hab noch kein file handling
		fromXML: function(xml) {
			if(typeof(xml) == "string") { // schon geparstes ist object
				xml = this.parser.parseFromString(xml, 'text/xml');
                this.cleanFormatting(xml);
			}
			if(xml.hasChildNodes()) {
                var item;
                for(var x = 0; x < xml.childNodes.length; x++) {
					item = xml.childNodes[x];
					if(item.nodeName == this.type) {
						this.fromXML(item); // remove outer layer
					}
					if(item.nodeName == "NextNodeID") {
						this.nextNodeId = item.childNodes[0].nodeValue;
					}
					if(item.nodeName == "Nodes") {
						// 端ber alle
						var node, element;
						for(var n = 0; n < item.childNodes.length; n++) {
							node = item.childNodes[n];
							if(node.nodeName == "FlowChartNode") {
								element = new ObjectiveNode();
								element.fromXML(node);
							}
							// bookmarks, classextender, usw.
						    this.push("nodes", element);
							this.nodesMap[element.id] = element;
						}
						// links aus dem Temp Status umformen
                        for(var node of this.nodes) {
                            node.activateLinks(this.nodesMap);
                        }
						// nodes anhand der links sortieren
						var i = 0;
						for(var node of this.nodes) {
							if(node.placed == false) {
								if(this.buckets[i] === undefined) this.buckets[i] = [];
								this.buckets[i].push(node); // id 0 als anker
								node.placed = true;
								i++;
								this.place(node.links, i);
							}
						}
						// dom anpassen, quasi eigenes template
						for(var bucket of this.buckets) {
							var bucketWrapper = document.createElement('div');
							Polymer.dom(this).appendChild(bucketWrapper);
							for(var node_ of bucket) {
								Polymer.dom(bucketWrapper).appendChild(node_);
							}
						}
					}
				}
			}
		},

		toXML: function() {
			var result = this.basetypecontent_toXML();
            // todo nicht gleiches
			return result + '</' + this.type + '>';
		}
	});

    var ConversationData = Polymer({
        is: "ConversationData-element",
        behaviors: [ParserBehavior],

        created: function() {
            this.type = "ConversationData";
			this.nodes = [];
			this.nodesMap = {};
			this.buckets = [];
        },

        fromXML: function(xml) {
			if(typeof(xml) == "string") { // schon geparstes ist object
				xml = this.parser.parseFromString(xml, 'text/xml');
                this.cleanFormatting(xml);
			}
			if(xml.hasChildNodes()) {
                var item;
                for(var x = 0; x < xml.childNodes.length; x++) {
					item = xml.childNodes[x];
					if(item.nodeName == this.type) {
						this.fromXML(item); // remove outer layer
					}
					if(item.nodeName == "NextNodeID") {
						this.nextNodeId = item.childNodes[0].nodeValue;
					}
					if(item.nodeName == "Nodes") {
						// 端ber alle
						var node, element;
						for(var n = 0; n < item.childNodes.length; n++) {
							node = item.childNodes[n];
							if(node.nodeName == "FlowChartNode") {
								element = new TalkNode();
								element.fromXML(node);
							}
							// bookmarks, classextender, usw.
						    this.push("nodes", element);
							this.nodesMap[element.id] = element;
						}
						// links aus dem Temp Status umformen
                        for(var node of this.nodes) {
                            node.activateLinks(this.nodesMap);
                        }
						// nodes anhand der links sortieren
						var i = 0;
						for(var node of this.nodes) {
							if(node.placed == false) {
								if(this.buckets[i] === undefined) this.buckets[i] = [];
								this.buckets[i].push(node); // id 0 als anker
								node.placed = true;
								i++;
								this.place(node.links, i);
							}
						}
						// dom anpassen, quasi eigenes template
						for(var bucket of this.buckets) {
							var bucketWrapper = document.createElement('div');
							Polymer.dom(this).appendChild(bucketWrapper);
							for(var node_ of bucket) {
								Polymer.dom(bucketWrapper).appendChild(node_);
							}
						}
					}
				}
			}
		},
        
		toXML: function() {
			var result = this.basetypecontent_toXML();
            // todo nicht gleiches
			return result + '</' + this.type + '>';
		}
    });
</script>
