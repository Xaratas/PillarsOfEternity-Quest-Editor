<link rel="import" href="functionCall-data-behavior.html">
<!-- TODO select element in polymer mit Hinweisen, was die Einträge bewirken -->
<dom-module id="Condition-element">
	<style>
		:host {
			display: flex;
			flex-direction: column;		 
		}
	</style>
	<template>
		<div>Operator: <span>{{operator}}</span></div>
		<div>Function:&nbsp;<span>{{not}}</span> <span>{{functionName}}</span></div>
		<template is="dom-repeat" items="{{parameter}}">
			<div>Parameter <span>{{index}}</span>: <span>{{item}}</span></div>
		</template>

		<nestedConditions></nestedConditions>
	</template>
</dom-module>
<script>
"use strict";
	// muss sachen wie fun1 && (fun2 || fun3) && !(fun4 && !fun5) unterstützen
	var ConditionElement = Polymer({
		is: "Condition-element",
		behaviors: [FunctionCallBehavior],

		properties: {
			operator: String,
			type: String,
			not: String,
			nestedConditions: Array
		},

		factoryImpl: function() {
			this.nestedConditions = [];
			this.parameter = [];
		},
		
		conditionalCall: function(xml) {
			var node;
			for (var x = 0; x < xml.length; x++) {
				node = xml[x];
				if (node.nodeName == "Data") {
					this.functionCallFromXML(node);
				}
				if (node.nodeName == "Not") {
					if(node.textContent == "false") this.not = "";
					else this.not = "!";
				}
				if (node.nodeName == "Operator") {
					this.operator = node.textContent;
				}
			}
		},
		conditionalExpression: function(xml) {
			if (xml[0].nodeName == "Operator") {
				this.operator = xml[0].textContent;
			}
			if (xml[1].nodeName == "Components") {
				// rekursion, liste von conditionals
				if (xml[1].hasChildNodes()) {
					for (var c = 0; c < xml[1].childNodes.length; c++) {
						var conditional = new ConditionElement();
						conditional.fromXML(xml[1].childNodes[c]);
						this.push('nestedConditions', conditional);
						Polymer.dom(this.$$("nestedConditions")).appendChild(conditional);
					}
				}
			}
		},
		fromXML: function(xml) {
			if (xml.hasChildNodes()) {
				if (xml.nodeName == "ExpressionComponent") {
					this.type = xml.attributes[0].value; // ConditionalCall or ConditionalExpression
				}
			   	if (xml.nodeName == "Conditionals") { // outer most layer
					this.type = "ConditionalExpression";
				}
				if (this.type == "ConditionalCall") {
					this.conditionalCall(xml.childNodes);
				} 
				if (this.type == "ConditionalExpression") {
					this.conditionalExpression(xml.childNodes);
				}
			}
		},

		/** The outermost layer of ConditionalExpression is called Conditionals in the XML 
		 * @param depth - 0 = outermost layer
		 */
		toXML: function(depth) {
			var xml = "";
			if(this.type == "ConditionalCall") {
				xml += '<ExpressionComponent xsi:type="' + this.type + '">'; 
				xml += this.functionCallToXML();	
				xml += '<Not>';
				if (this.not === "")
					xml += 'false';
				else
					xml += 'true';
				xml += '</Not>' 
					+ '<Operator>' + this.operator + '</Operator>';
				xml += '</ExpressionComponent>';
			}
			if(this.type == "ConditionalExpression") {
				if(depth > 0) {
					xml += '<ExpressionComponent xsi:type="' + this.type + '">';
				}
				xml += '<Operator>' + this.operator + '</Operator>'
					+ '<Components>';
				for(var condition of this.nestedConditions) {
					xml += condition.toXML(depth + 1);
				}				
				xml += '</Components>';
				if(depth > 0) {
					xml += '</ExpressionComponent>';
				}
			}
			return xml;
		}
	});
</script>
