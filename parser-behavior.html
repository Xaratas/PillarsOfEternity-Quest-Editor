<script>
"use strict";
/** Cleans text xml input of whitespace-elements */
var ParserBehavior = {
	properties: {
		type: String,
		nextNodeId: Number,
		nodes: Array, // jeder Typ braucht einen eigenen Array, nicht vorinitialisieren
		buckets: Array, 
		parser: {
			type: Object,
			value: new window.DOMParser()
		}
	},


	cleanFormatting: function(node) {
		var reBlank = /^\s*$/;
		var child, next;
		switch (node.nodeType) {
			case 3: // Text node
				if (reBlank.test(node.nodeValue)) {
					node.parentNode.removeChild(node);
				}
				break;
			case 1: // Element node
			case 9: // Document node
				child = node.firstChild;
				while (child) {
					next = child.nextSibling;
					this.cleanFormatting(child);
					child = next;
				}
				break;
		}
	},

	basetypecontent_toXML: function() {
		var result = '<?xml version="1.0" encoding="utf-8"?><' + this.type + ' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">';
		result += '<NextNodeID>' + this.nextNodeId + '</NextNodeID>';
		result += '<Nodes>';
		for (var node of this.nodes) {
			result += node.toXML();
		}
		result += '</Nodes>';
		// todo gleicher rest
		return result;
	},

	/** Place link targets in buckets, new reachable elements get in a new bucket */
	place: function(links, i) {
		for(var link in links) {
			if(this.buckets[i] === undefined) this.buckets[i] = [];
			if(links[link].endElement.placed == false) {
				this.buckets[i].push(links[link].endElement);
				links[link].endElement.placed = true;
				this.place(links[link].endElement.links, i+1); 
			}
		}
	}
};
</script>
