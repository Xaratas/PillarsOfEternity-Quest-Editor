<link rel="import" href="bower_components/polymer/polymer.html">
<link rel="import" href="parser-behavior.html">
<link rel="import" href="flowChartNode-elements.html">

<!-- Quest Farbpalette
	Hell: #EDEFFF
	hell blau: #A9D3FF
	mittel blau: #96C5F7
	dunkel blau: #75A6C6
	highlight gr端n: #6782A7
-->	

<dom-module id="QuestData-element">
	<style>
		:host {
			display: flex;
		}

		:host > ::content > div {
			display:flex;
			flex-direction: column;
			margin-left: 30px;
		    margin-right: 30px;
		}

		:host > ::content > div:first-child {
			margin-left: 0;	
		}
	   
		:host > ::content > div:last-child {
			margin-right: 0;
		}
	</style>
	<template>
		<content></content>
	</template>
</dom-module>

<!-- Farbpalette:
	Hell: #D1FCF0
	helles cyan: #9FD8CB
	muted gr端n: #8FC0A9
	ocker: #ADBF97
	highlight muted gelb: #E2EB98
-->

<dom-module id="ConversationData-element">
	<style>
		:host {
			display: flex;
		}

		:host > ::content > div {
			display:flex;
			flex-direction: column;
			margin-left: 30px;
		    margin-right: 30px;
		}

		:host > ::content > div:first-child {
			margin-left: 0;	
		}
	   
		:host > ::content > div:last-child {
			margin-right: 0;
		}
	</style>

	<template>
		<content></content>
	</template>
</dom-module>

<script>
"use strict";

	var QuestData = Polymer({
		is: "QuestData-element",
        behaviors: [ParserBehavior],

		created: function() {
            this.type = "QuestData";
			this.nodes = [];
			this.nodesMap = {};
			this.buckets = [];
        },

		// geht erstmal von text aus, hab noch kein file handling
		fromXML: function(xml) {
			if(typeof(xml) == "string") { // schon geparstes ist object
				xml = this.parser.parseFromString(xml, 'text/xml');
                this.cleanFormatting(xml);
			}
			if(xml.hasChildNodes()) {
                var item;
                for(var x = 0; x < xml.childNodes.length; x++) {
					item = xml.childNodes[x];
					if(item.nodeName == this.type) {
						this.fromXML(item); // remove outer layer
					}
					if(item.nodeName == "NextNodeID") {
						this.nextNodeId = item.childNodes[0].nodeValue;
					}
					if(item.nodeName == "Nodes") {
						// 端ber alle
						var node, element;
						for(var n = 0; n < item.childNodes.length; n++) {
							node = item.childNodes[n];
							if(node.nodeName == "FlowChartNode") {
								element = new ObjectiveNode(this);
								element.fromXML(node);
							}
							// bookmarks, classextender, usw.
						    this.push("nodes", element);
							this.nodesMap[element.id] = element;
						}
						// links aus dem Temp Status umformen
                        for(var node of this.nodes) {
                            node.activateLinks(this.nodesMap);
                        }
						// nodes anhand der links sortieren
						var i = 0;
						for(var node of this.nodes) {
							if(node.placed === false) {
								if(this.buckets[i] === undefined) this.buckets[i] = [];
								this.buckets[i].push(node); // id 0 als anker
								node.placed = true;
								i++;
								this.place(node.links, i);
							}
						}
						// dom anpassen, quasi eigenes template
						for(var bucket of this.buckets) {
							var bucketWrapper = document.createElement('div');
							Polymer.dom(this).appendChild(bucketWrapper);
							for(var node_ of bucket) {
								Polymer.dom(bucketWrapper).appendChild(node_);
							}
						}
					}
				}
			}
		},

		toXML: function() {
			var result = this.basetypecontent_toXML();
            // todo nicht gleiches
			return result + '</' + this.type + '>';
		}
	});

    var ConversationData = Polymer({
        is: "ConversationData-element",
        behaviors: [ParserBehavior],

		properties: {
			/** Valid Values: Conversation or Chatter */
			conversationType: String,
			characterMappings: Array // array of objects with Guid and InstanceTag
		},

        created: function() {
            this.type = "ConversationData";
			this.nodes = [];
			this.nodesMap = {};
			this.buckets = [];
			this.characterMappings = [];
        },

        fromXML: function(xml) {
			if(typeof(xml) == "string") { // schon geparstes ist object
				xml = this.parser.parseFromString(xml, 'text/xml');
                this.cleanFormatting(xml);
			}
			if(xml.hasChildNodes()) {
                var item;
                for(var x = 0; x < xml.childNodes.length; x++) {
					item = xml.childNodes[x];
					if(item.nodeName == this.type) {
						this.fromXML(item); // remove outer layer
					}
					if(item.nodeName == "NextNodeID") {
						this.nextNodeId = item.childNodes[0].nodeValue;
					}
					if(item.nodeName == "Nodes") {
						// 端ber alle
						var node, element;
						for(var n = 0; n < item.childNodes.length; n++) {
							node = item.childNodes[n];
							if(node.nodeName == "FlowChartNode") {
								element = new TalkNode(this);
								element.fromXML(node);
							}
							// bookmarks, classextender, usw.
						    this.push("nodes", element);
							this.nodesMap[element.id] = element;
						}
						// links aus dem Temp Status umformen
                        for(var node of this.nodes) {
                            node.activateLinks(this.nodesMap);
                        }
						// nodes anhand der links sortieren
						var i = 0;
						for(var node of this.nodes) {
							if(node.placed === false) {
								if(this.buckets[i] === undefined) this.buckets[i] = [];
								this.buckets[i].push(node); // id 0 als anker
								node.placed = true;
								i++;
								this.place(node.links, i);
							}
						}
						// dom anpassen, quasi eigenes template
						for(var bucket of this.buckets) {
							var bucketWrapper = document.createElement('div');
							Polymer.dom(this).appendChild(bucketWrapper);
							for(var node_ of bucket) {
								Polymer.dom(bucketWrapper).appendChild(node_);
							}
						}
					}
					if(item.nodeName == "Bookmarks") {} // ignore
					if(item.nodeName == "ClassExtender") {} // ignore
					if(item.nodeName == "ConversationType") {
						this.conversationType = item.textContent;
					}
					if(item.nodeName == "Description") {} // ignore
					if(item.nodeName == "SceneLocation") {} // ignore
					if(item.nodeName == "SceneTime") {} // ignore
					if(item.nodeName == "CharacterMappings") {
						if(item.hasChildNodes) {
							var node;
							for(var i = 0; i < item.childNodes.length; i++) {
								node = item.childNodes[i];
								if(node.hasChildNodes) {
									var guid = node.childNodes[0].textContent;
									var instanceTag = node.childNodes[1].textContent;
									this.characterMappings[i] = {'guid' : guid, 'instanceTag': instanceTag};
								}
							}
						}
					}
				}
			}
		},
        
		toXML: function() {
			var result = this.basetypecontent_toXML();
            // todo nicht gleiches
			result += '<ConversationType>' + this.conversationType + '</ConversationType>';
			// Nicht weiter wichtig, solange die Community nicht einen Weg findet die Texte zu vertonen
			result += '<Description>Scene description.</Description>';
			result += '<SceneLocation>SCENE LOCATION</SceneLocation>';
			result += '<SceneTime>SCENE TIME</SceneTime>';
			result += '<CharacterMappings>';
			for(var i = 0; i < this.characterMappings.length; i++) {
				result += '<CharacterMapping>';
				result += '<Guid>' + this.characterMappings[i].guid + '</Guid>';
				result += '<InstanceTag>' + this.characterMappings[i].instanceTag + '</InstanceTag>';
				result += '</CharacterMapping>';
			}
			result += '</CharacterMappings>';
			return result + '</' + this.type + '>';
		},

		
        stringsFromXML: function(xml) { // TODO Als Global definieren
			var types = ["TalkNode", "PlayerResponseNode", "TriggerConversationNode", "BankNode", "ScriptNode"];
			if(typeof(xml) == "string") { // schon geparstes ist object
				xml = this.parser.parseFromString(xml, 'text/xml');
                this.cleanFormatting(xml);
			}
			if(xml.hasChildNodes) {
				var node;
				for	(var x = 0; x < xml.childNodes.length; x++) {
					node = xml.childNodes[x];
					if(node.nodeName == "StringTableFile") {
						this.stringsFromXML(node); // outer layer
					}
					if(node.nodeName == "Name") {
						this.stringTableFileLink = node.textContent;
					}
					if(node.nodeName == "NextEntryID") {
						this.nextEntryID = node.textContent; // nicht wirklich wichtig, vom tool aber es gibt illegale Werte bei Obsidian Files
					}
					if(node.nodeName == "EntryCount") {
						this.entryCount = node.textContent;
					}
					if(node.nodeName == "Entries") {
						var entry;
						for(var n = 0; n < node.childNodes.length; n++) {
							entry = node.childNodes[n];
							for(var type of types) {
								var talkNode = this.nodesMap[type + entry.childNodes[0].textContent];
								if(talkNode !== undefined) {
									talkNode.setText(entry.childNodes[1].textContent, entry.childNodes[2].textContent);
								}
							}
						}
					}
				}
			}	
		}
    });
</script>
