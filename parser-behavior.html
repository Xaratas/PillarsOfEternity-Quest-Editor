<script>
"use strict";
/** Cleans text xml input of whitespace-elements */
var ParserBehavior = {
	properties: {
		type: String,
		nextNodeId: Number,
		nodes: Array, // jeder Typ braucht einen eigenen Array, nicht vorinitialisieren
		buckets: Array, 
		parser: {
			type: Object,
			value: new window.DOMParser()
		},

		/** Stringtable file data */
		stringTableFileLink: String,
		nextEntryID: Number,
		entryCount: Number
	},


	cleanFormatting: function(node) {
		var reBlank = /^\s*$/;
		var child, next;
		switch (node.nodeType) {
			case 3: // Text node
				if (reBlank.test(node.nodeValue)) {
					node.parentNode.removeChild(node);
				}
				break;
			case 1: // Element node
			case 9: // Document node
				child = node.firstChild;
				while (child) {
					next = child.nextSibling;
					this.cleanFormatting(child);
					child = next;
				}
				break;
		}
	},

	basetypecontent_toXML: function() {
		var result = '<?xml version="1.0" encoding="utf-8"?><' + this.type + ' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">';
		result += '<NextNodeID>' + this.nextNodeId + '</NextNodeID>';
		result += '<Nodes>';
		for (var node of this.nodes) {
			result += node.toXML();
		}
		result += '</Nodes>';
		// Nur ein Bookmark um den Game Parser zufrieden zu stellen. Der Questeditor hat keine eigenen Bookmarks und ingame sind sie Ã¼berhaupt nicht relevant
		result += '<Bookmarks><Bookmark><Type>Unassigned</Type><Name /><NodeID>-1</NodeID><GhostNodeParentID>-1</GhostNodeParentID></Bookmark></Bookmarks>';
		result += '<ClassExtender><ExtendedProperties /></ClassExtender>';
		return result;
	},

	stringsToXML: function() {
		var result = '<?xml version="1.0" encoding="utf-8"?><StringTableFile xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">';
		result += '<Name>' + this.stringTableFileLink + '</Name>';
		result += '<NextEntryID>' + this.nextEntryID + '</NextEntryID>'; // Das was Obsidian verhunzt hat ordentlich machen
		result += '<EntryCount>' + this.nodes.length + '</EntryCount>';
		result += '<Entries>';
		for(var i = 0; i < this.nodes.length; i++) {
			var text = this.nodes[i].defaultText;
			result += '<Entry>';
			result += '<ID>' + this.nodes[i].nodeId + '</ID>';
			if(text !== undefined && text !== "") {
				result += '<DefaultText>' + text + '</DefaultText>';
			} else {
				result += '<DefaultText />';
			}
			text = this.nodes[i].femaleText;
			if(text !== undefined && text !== "") {
				result += '<FemaleText>' + text + '</FemaleText>';
			} else {
				result += '<FemaleText />';
			}
			result += '</Entry>';
		}
		result += '</Entries>';
		return result;
	},

	/** Place link targets in buckets, new reachable elements get in a new bucket */
	place: function(links, i) {
		for(var link of Object.keys(links)) {
			if(this.buckets[i] === undefined) this.buckets[i] = [];
			if(links[link].endElement.placed === false) {
				this.buckets[i].push(links[link].endElement);
				links[link].endElement.placed = true;
				this.place(links[link].endElement.links, i+1); 
			}
		}
	},

	selectNone: function() {
		for(var node of this.nodes) {
			this.toggleClass("selected", false, node);
			for(var link of Object.keys(node.links)) {
				node.links[link].connect('#f00');
			}
		}
	}	
};
</script>
